function [fx_lr, gx_lr, ux_lr, vx_lr] = STLN_Derivative_Constraint(fx,k)
% Given the polynomial f(x) and the degree of the GCD of f(x) and its
% derivative. Calculate the low rank approximation of the Sylvester
% subresultant matrix S_{t}(f,f')
%
% % Inputs
%
% fx : Coefficients of polynomial f(x)
%
% k : Degree of GCD d(x)
%
% % Outputs
%
% fx_lr :
%
% gx_lr :

global MAX_ERROR_SNTLN 
global MAX_ITE_SNTLN


% Get degree of polynomial f(x)
m = GetDegree(fx);

% Get the derivative of f(x)
gx = Differentiate(fx);
n = m -1 ;

% Build the Sylvester matrix
C1 = BuildT1(fx,n-k);
C2 = BuildT1(gx,m-k);
St = [C1 C2];

% Get the index of the optimal colummn for removal
[~,idx_col] = GetMinDistance(St);

% Get Ak
Ak = St;
Ak(:,idx_col) = [];
ck = St(:,idx_col);

% Initialise the matrix of perturbations E_t
Ek = zeros(size(Ak));

% Initialise the vector h_{t} 
hk = zeros(size(ck));

% Build the matrix P
Pk = BuildP(idx_col,m,k);


% Initalise the matrix z of structured perturbations to f(x)
% delta_z = zeros(m+1,1);
% delta_x = zeros(2*m-2*t+1,1);

% Build the matrix D
D = ...
    [
    m-k             zeros(1,m);
    zeros(m,1)    (2*m-k*k+1).*eye(m);
    ];

% Build the matrix Y_{t}
xk = SolveAx_b(Ak,ck);
x = [xk(1:idx_col-1) ;0; xk(idx_col:end)];
Yt = BuildY(x,m,k);


% Build the matrix E from the minimsation problem. Minimise Ew-p subject to
% Cw = q.
E = [D zeros(m+1,2*m-2*k+1)];

% Get the residual vector
res_vec = (ck + hk) - (Ak*xk);

% Initialise iteration number
ite = 1;

% Get termination criterion - Set to the norm of the residual vector
condition(ite) = norm(res_vec) ./ norm(ck);

% Initialise z vector of perturbations to f
zf = zeros(m+1,1);


H_z = Yt - Pk;
H_x = Ak + Ek;
C = [H_z H_x];

% Define the starting vector for the iterations for the LSE problem.
start_point     =   ...
    [
    zf;
    xk;
    ];

yy =   start_point;

f = -(yy-start_point);

while condition(ite) > MAX_ERROR_SNTLN && ite < MAX_ITE_SNTLN
    
    
    
    y = LSE(E,f,C,res_vec);
    
    delta_z = y(1:m+1,1);
    delta_x = y(m+2:end,1);
    
    yy = yy + y;
    
    % (f) set x:=x+\delta x and z:= z+\delta_z
    % Update z
    zf = zf + delta_z;
    
    % Update x
    xk = xk + delta_x;
    
    
    % (g) Update E_{t} and h_{t} from z, and Yk from x
    
    % % Build new Et
    zg = Differentiate(zf);
    
    % Build the matrix E_{t}
    E1 = BuildT1(zf,m-1-k);
    E2 = BuildT1(zg,m-k);
    Bt = [E1 E2];
    
    Ek = Bt;
    Ek(:,idx_col) = [];
    hk = Bt(:,idx_col);

    % % Build new Yt
    x = [xk(1:idx_col-1) ;0; xk(idx_col:end)];
    Yt = BuildY(x,m,k);
    
    res_vec = (ck+hk) - ((Ak+Ek)*xk);
    
    % Update the matrix C
    H_z = Yt - Pk;
    H_x = Ak + Ek;
    C = [H_z H_x];
    
    

    
    % Update fnew - used in LSE Problem.
    f = -(yy-start_point);
    
    % Increment iteration number
    ite = ite + 1;
    
    condition(ite) = norm(res_vec) ./ norm(ck+hk) ;
    
    
    
end

figure('name','STLN - Residuals')
hold on
plot(log10(condition));
hold off

LineBreakLarge()
fprintf('Required number of iterations : %i \n',ite)
LineBreakLarge()

% Output coefficients of f(x) + delta f(x)
fx_lr = fx + zf;
gx_lr = gx + zg;

% Get u(x) and v(x)
x = [xk(1:idx_col-1) ; -1 ; xk(idx_col:end)];
vx_lr = x(1:nCoeffs_vx);
ux_lr = -1.* x(nCoeffs_vx + 1: end);

end




function Pk = BuildP(idx_col,m,k)
% Build the matrix P such that a column in Ek, specified by the column index
% is generated by the matrix vector product P*z, or a column of Ak is given
% by P*z
%
% % Inputs
%
% idx_col : Index of column c_{k} removed from S_{k}(f,g)
%
% m : Degree of polynomial f(x)
%
% k : index of kth Sylvester subresultant matrix S_{k}(f,g)


n = m-1;
% Get number of columns in the first partition T_{n-k}(f) of the Sylvester
% subresultant matrix
nCols_Tf = n-k+1;

if idx_col <= nCols_Tf % Column is from 1st partition T(f)
    
    % Get the index of the column relative to T_{n-k}(f)
    idx_col_rel = idx_col;
    
    mat = ...
        [
        zeros(idx_col_rel-1,m+1);
        diag(ones(m+1,1));
        zeros(m-k-idx_col_rel,m+1);
        ];
    
    Pk = mat;
    
elseif idx_col > m-k && idx_col <= 2*m-2*k+1 % Column is from 2nd partition
    
    % Get the index of the column relative to T_{n-k}(f)
    idx_col_rel = idx_col - (m-k);
    
    mat = ...
        [
        zeros(idx_col_rel-1,m+1);
        zeros(m,1) diag(1:1:m);
        zeros(m-k-idx_col_rel+1,m+1);
        ];
    % Remove the first row
    Pk = mat;
    
end

end


function Y = BuildY(x,m,t)

% The first (m-t) coefficients are for the first matrix
xa = x(1:m-t);
xb = x(m-t+1:end);

mat1 = BuildT1(xa,m);
mat2 = BuildT1(xb,m-1);

mat2 =  [zeros(2*m-t,1) mat2 ] * diag(0:1:m) ;

Y = mat1 + mat2;

end